# Community guide

## Получение локального репозитория

Есть два основных способа получения локального репозитория проекта:
- fork
- Стать contributor и использовать доступ к репозиторию напрямую

Для сторонних разработчиков приоритетным является первый вариант

## Скачивание репозитория

> После скачивания в корне проекта должна находиться директория .git. Посмотреть это можно командой `ls -a` для Linux и `dir /s` для Windows.

### git cli

- SSH `$ git clone `
- HTTPS `$ git clone `

> Если вы делали fork то помните, что в `$ git clone` стоит указать ссылку на свой fork, либо использовать команду `$ git remote set-url origin <fork-link>` после скачивания репозитория для изменения ссылки на **origin**

### git gui

Задайте **Source Location** (ссылка на репозиторий) и **Target Directory** (место на локальном диске, куда сохранятся файлы проекта)

### Использование GitHub Desktop для скачивания проекта

На главной странице репозитория откройте вкладку **<> Code**. В опциях загрузки будет вариант открытия в **GitHub Desktop**

### Скачивание кода напрямую с GitHub

> Данный способ не рекомендуется, так как git репозиторий в таком случае настроен не будет.

На главной странице репозитория откройте вкладку **<> Code**. В опциях загрузки будет вариант скачивания кода как .zip или .tar.gz архива. Выберете удобный вариант 

# Процесс разработки 

> Важно соблюдать стрцктуру проекта. В корневой директории Assets помимо вложенных папок *допускается* наличие экземпляров **Scriptable Object** и каких-либо глобальных настроек для GUI/редактора

## Редактор Unity

Соблюдайте структуру проекта. Создавайте сцены из шаблона. Сохраняйте общие настройки объектов как Prefab, а модификации настроек, которые планируется использовать несколько раз как Prefab Variant. *Не рекомендуется* наличие null-полей в настройках скриптов, кроме случаев, где этого избежать не удается.

## C# Code

Соблюдайте читабельный нейминг переменных. **Не допускаются** названия переменных, не отражающие их использование (напр. **int a;**, **float variable**). **uint i** в контексте использования в цикле **for** допустимо, так как отражает суть переменной (***i - iterator***)

Избегайте использования типа **auto**. Избегайте использования static переменных, кроме случаев, где это необходимо, а состояние статического поля проверяется (при смене уровня не возникнет ссылка на нулевую оьласть памяти). Например, это допускается в контексте поля *instance* Singleton-классов.
Избегайте использования GetComponent, Find, поиска по тегу и т.д. Избегайте использования public переменных, кроме случаев, где get/set избыточны (поле может быть изменено из любого места без требования к значению). Используйте get/set конструкции, *рекомендуется* проведение проверки **value** в set.

# Применение изменений 

**main** и **test** ветки защищены от прямых изменений. Заводите отдельную ветку под свою задачу. *Рекомендуется* соблюдать нейминг веток типа `wip/task-name`. **Обязательно** использовать "говорящее" название ветки, не допускается название веток типа `branch`, `1234`, `master` и прочие подобные. 

Процесс применения изменений может быть следующим: (помните, что название ветки может отличаться)

### git cli

```
$ git pull
$ git checkout -b wip/branch-name
$ git add *
$ git commit -m "Changes description, e.g. Added new game level"
$ git push -u origin wip/branch-name
```

### GitHub Desktop

- Сделайте fetch origin и pull при наличии изменений
- Переключитесь на свою ветку
- Добавьте нужные файлы и напишите commit message
- Примените коммит и сделайте push

# Создание Pull Request

Ветки wip/* необходимо влить в **test** путем создания Pull Request. После тестирования изменения будут применены в **main**

> Рекомендуется длбавление комментария к Pull Request с кратким описанием изменений.

> Нейминг веток и коммитов на русском не допускается, комментарии на русском разрешены

___
Created by: Keyboard Destroyer 
